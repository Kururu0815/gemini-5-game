<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* 禁用双击缩放 */
        }
        .board-container {
            /* 棋盘背景颜色 */
            background-color: #dcb35c; 
        }
        canvas {
            cursor: pointer;
        }
        .status-panel {
            min-height: 80px; /* 确保高度稳定，防止布局变化 */
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-lg mx-auto bg-white dark:bg-gray-800 rounded-2xl shadow-2xl p-6 text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-800 dark:text-white mb-4">五子棋</h1>
        
        <!-- 游戏状态显示面板 -->
        <div id="status-panel" class="status-panel mb-4 p-3 bg-gray-100 dark:bg-gray-700 rounded-lg flex flex-col items-center justify-center">
            <p id="status" class="text-xl font-semibold text-gray-700 dark:text-gray-200">黑棋回合</p>
            <div id="winner-display" class="hidden mt-1">
                <span id="winner-stone" class="w-6 h-6 rounded-full inline-block align-middle mr-2"></span>
                <span id="winner-text" class="text-lg font-bold"></span>
            </div>
        </div>

        <!-- 棋盘容器 -->
        <div class="board-container rounded-lg shadow-inner overflow-hidden aspect-square">
            <canvas id="gomoku-board"></canvas>
        </div>

        <!-- 重置按钮 -->
        <button id="restart-button" class="mt-6 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300 dark:focus:ring-blue-800">
            重新开始
        </button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gomoku-board');
            const statusEl = document.getElementById('status');
            const winnerDisplayEl = document.getElementById('winner-display');
            const winnerStoneEl = document.getElementById('winner-stone');
            const winnerTextEl = document.getElementById('winner-text');
            const restartButton = document.getElementById('restart-button');
            const ctx = canvas.getContext('2d');

            const BOARD_SIZE = 15;
            let cellSize;
            let board = [];
            let currentPlayer = 'black';
            let gameOver = false;
            let moves = 0;
            let isAnimating = false;

            function initGame() {
                board = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
                currentPlayer = 'black';
                gameOver = false;
                moves = 0;
                isAnimating = false;
                resizeCanvas();
                drawBoard();
                updateStatus();
            }

            function resizeCanvas() {
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight);
                canvas.width = size;
                canvas.height = size;
                cellSize = canvas.width / (BOARD_SIZE + 1);
                drawBoard();
                redrawStones();
            }

            function drawBoard() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#dcb35c';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                for (let i = 0; i < BOARD_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(cellSize * (i + 1), cellSize);
                    ctx.lineTo(cellSize * (i + 1), canvas.height - cellSize);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cellSize, cellSize * (i + 1));
                    ctx.lineTo(canvas.width - cellSize, cellSize * (i + 1));
                    ctx.stroke();
                }
                drawStarPoint(3, 3); drawStarPoint(3, 11);
                drawStarPoint(11, 3); drawStarPoint(11, 11);
                drawStarPoint(7, 7);
            }
            
            function drawStarPoint(x, y) {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(cellSize * (x + 1), cellSize * (y + 1), cellSize / 8, 0, 2 * Math.PI);
                ctx.fill();
            }

            function drawStone(x, y, player, radius) {
                const r = radius !== undefined ? radius : cellSize / 2 * 0.9;
                if (r <= 0) return;
                const gradient = ctx.createRadialGradient(
                    cellSize * (x + 1) - r / 3, cellSize * (y + 1) - r / 3, r / 4,
                    cellSize * (x + 1), cellSize * (y + 1), r
                );
                if (player === 'black') {
                    gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000');
                } else {
                    gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd');
                }
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cellSize * (x + 1), cellSize * (y + 1), r, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            function redrawStones() {
                for(let y = 0; y < BOARD_SIZE; y++) {
                    for (let x = 0; x < BOARD_SIZE; x++) {
                        if (board[y][x]) {
                            drawStone(x, y, board[y][x]);
                        }
                    }
                }
            }
            
            function updateStatus() {
                if (gameOver && moves !== BOARD_SIZE * BOARD_SIZE) {
                    statusEl.classList.add('hidden');
                    winnerDisplayEl.classList.remove('hidden');
                    const winnerName = currentPlayer === 'black' ? '黑棋' : '白棋';
                    winnerTextEl.textContent = `${winnerName} 获胜!`;
                    winnerStoneEl.style.backgroundColor = currentPlayer;
                    winnerTextEl.style.color = currentPlayer === 'black' ? '#000' : '#FFF';
                    if (currentPlayer === 'white') {
                        winnerTextEl.classList.add('dark:text-gray-800');
                    } else {
                        winnerTextEl.classList.remove('dark:text-gray-800');
                    }
                } else if (moves === BOARD_SIZE * BOARD_SIZE) {
                    statusEl.textContent = '平局!';
                    statusEl.classList.remove('hidden');
                    winnerDisplayEl.classList.add('hidden');
                } else {
                    const nextPlayerName = currentPlayer === 'black' ? '黑棋' : '白棋';
                    statusEl.textContent = `${nextPlayerName}回合`;
                    statusEl.classList.remove('hidden');
                    winnerDisplayEl.classList.add('hidden');
                }
            }

            // 修改: 检查胜利条件, 如果获胜则返回获胜棋子数组
            function checkWin(x, y) {
                const player = board[y][x];
                const directions = [{ x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 1, y: -1 }];
                for (const dir of directions) {
                    let line = [{x, y}];
                    // 正方向
                    for (let i = 1; i < 5; i++) {
                        const newX = x + i * dir.x, newY = y + i * dir.y;
                        if (newX >= 0 && newX < BOARD_SIZE && newY >= 0 && newY < BOARD_SIZE && board[newY][newX] === player) {
                            line.push({x: newX, y: newY});
                        } else break;
                    }
                    // 反方向
                    for (let i = 1; i < 5; i++) {
                        const newX = x - i * dir.x, newY = y - i * dir.y;
                        if (newX >= 0 && newX < BOARD_SIZE && newY >= 0 && newY < BOARD_SIZE && board[newY][newX] === player) {
                            line.push({x: newX, y: newY});
                        } else break;
                    }
                    if (line.length >= 5) return line; // 返回获胜棋子
                }
                return null; // 没有获胜
            }

            function animateStonePlacement(x, y, player) {
                isAnimating = true;
                const startTime = performance.now();
                const duration = 150;
                const finalRadius = cellSize / 2 * 0.9;

                function animationStep(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easedProgress = 1 - Math.pow(1 - progress, 3);
                    const currentRadius = finalRadius * easedProgress;
                    drawBoard();
                    redrawStones();
                    drawStone(x, y, player, currentRadius);

                    if (progress < 1) {
                        requestAnimationFrame(animationStep);
                    } else {
                        board[y][x] = player;
                        moves++;
                        
                        const winningLine = checkWin(x, y);
                        if (winningLine) {
                            gameOver = true;
                            animateVictory(winningLine); // 触发胜利动画
                        } else if (moves === BOARD_SIZE * BOARD_SIZE) {
                            gameOver = true;
                            isAnimating = false;
                            updateStatus();
                        } else {
                            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
                            isAnimating = false;
                            updateStatus();
                        }
                    }
                }
                requestAnimationFrame(animationStep);
            }

            // 新增：胜利动画函数
            function animateVictory(winningLine) {
                const startTime = performance.now();
                const duration = 1500; // 动画总时长

                function victoryStep(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = elapsed / duration;

                    drawBoard();
                    redrawStones();

                    // 绘制闪烁光环
                    const pulse = Math.abs(Math.sin(elapsed / 150)); // 控制闪烁频率
                    const glowRadius = (cellSize / 2) * (1 + pulse * 0.3);
                    ctx.fillStyle = `rgba(255, 215, 0, ${0.7 * (1 - progress)})`; // 光环随时间渐隐

                    for (const stone of winningLine) {
                        ctx.beginPath();
                        ctx.arc(cellSize * (stone.x + 1), cellSize * (stone.y + 1), glowRadius, 0, 2 * Math.PI);
                        ctx.fill();
                        // 重绘获胜棋子，确保在光环之上
                        drawStone(stone.x, stone.y, board[stone.y][stone.x]);
                    }

                    if (progress < 1) {
                        requestAnimationFrame(victoryStep);
                    } else {
                        isAnimating = false;
                        updateStatus(); // 动画结束后更新最终状态
                        // 确保最终高亮
                        drawBoard();
                        redrawStones();
                        ctx.strokeStyle = 'gold';
                        ctx.lineWidth = 3;
                         for (const stone of winningLine) {
                            ctx.beginPath();
                            ctx.arc(cellSize * (stone.x + 1), cellSize * (stone.y + 1), cellSize/2, 0, 2 * Math.PI);
                            ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(victoryStep);
            }

            canvas.addEventListener('click', (e) => {
                if (gameOver || isAnimating) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const gridX = Math.round(x / cellSize) - 1;
                const gridY = Math.round(y / cellSize) - 1;
                if (gridX >= 0 && gridX < BOARD_SIZE && gridY >= 0 && gridY < BOARD_SIZE && !board[gridY][gridX]) {
                    animateStonePlacement(gridX, gridY, currentPlayer);
                }
            });

            restartButton.addEventListener('click', initGame);
            window.addEventListener('resize', resizeCanvas);
            initGame();
        });
    </script>
</body>
</html>
